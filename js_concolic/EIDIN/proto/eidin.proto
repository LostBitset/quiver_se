syntax = "proto3";
package eidin;

option go_package = "LostBitset/quiver_se/EIDIN/proto_lib";

// Start a new session, describes important operation parameters and target.
// Direction: Orchestration Process -> Analyzer Process
message SessionInit {

    // The EIDIN version number, the first of which is "0.1"
    string eidin_version = 1;

    // The format used for constraints / SMT queries.
    // Keep in mind that complete queries are never sent as a part of this protocol. 
    enum ConstraintFormat {
        SMTLIB_V2 = 0;
        SMTLIB_2VA = 1;
        OTHER = 2;
    }

    // Target Program URI
    // It is entirely up to the implementation what to support.
    // Some may support only file:// URIs, others may not support them at all.
    // The spec requires that this is a valid URI, in accordance with RFC 3986.
    string target_uri = 2;

    // If the ConstraintFormat was OTHER, you should specify what it is.
    // Failure to do this is not breaking the spec, but is highly discouraged.
    // For very limited testing or trial environments, this is allowed, but it should
    // never be used in a complex or production environment. Think of this case as
    // sending "unspecified". 
    // *HOWEVER*, setting this when ConstraintFormat is not OTHER, *DOES* constitute
    // breaking the spec.
    optional string constraint_format_other = 3;

}

// Analyze the target program on any input (random or predefined).
// Direction: Orchestration Process -> Analyzer Process
message AnalyzeAny {

    // An ID associated with this particular request.
    string request_id = 1;

    // Whether or not sending this message multiple times is not allowed to just yield a
    // cached result.
    // Note that if this value is false, sending this message (AnalyzeAny) more than once
    // breaks the spec.
    bool forbid_caching = 2;

}

// Analyze the target program in accordance with a particular model.
// Direction: Orchestration Process -> Analyzer Process
message AnalyzeModel {

    // An ID associated with this particular request.
    string request_id = 1;

    // Whether or not sending this message multiple times is not allowed to just yield a
    // cached result.
    bool forbid_caching = 2;

    // The model, in accordance with the constraint format specified in SessionInit.
    string model = 3;

}

// Provides the returned path condition (analysis results).
// Direction: Analyzer Process -> Orchestration Process
message PathCondition {

    // An ID associated with this particular request.
    string request_id = 1;

    // Free functions that make up the SMT query.
    repeated SMTFreeFun free_funs = 2;

    // The segmented path condition.
    repeated PathConditionSegment segmented_pc = 3;

}

// Requests the source of a particular callback that analysis discovered.
// Direction: Orchestration Process -> Analyzer Process
message RequestCallbackSource {

    // The unique identifier associated with the callback in question.
    string callback_id = 1;

}

// The requested source of a particular callback that analysis discovered.
// Direction: Analyzer Process -> Orchestration Process
message CallbackSource {

    // The unique identifier associated with the callback in question.
    string callback_id = 1;

    // The start byte of the callback source in the original program.
    uint64 source_index_start = 2;

    // The end byte of the callback source in the original program.
    uint64 source_index_end = 3;

}

// NOT AN ACTUAL MESSAGE, just a component of one.
// Represents a "free fun" in an SMT constraint set.
message SMTFreeFun {

    // The name of the fun.
    string name = 1;
    
    // The sorts of the arguments, which should be empty if it's just a normal value.
    repeated string arg_sorts = 2;
    
    // The sort of the (return) value.
    string ret_sort = 3;

}

// NOT AN ACTUAL MESSAGE, just a component of one.
// Represents a segment of a path condition, divided in accordance with callback transitions.
message PathConditionSegment {

    // A unique identifier for the callback this segment refers to.
    string this_callback_id = 1;
    
    // A unique identifier for the callback this segment continues on to.
    string next_callback_id = 2;
    
    // The actual constraint set that makes up this part of the query
    repeated SMTConstraint partial_pc = 3;

}

// NOT AN ACTUAL MESSAGE, just a component of one.
// Represents a constraint that forms a part of the query given to an SMT solver.
message SMTConstraint {

    // The constraint as a string.
    string constraint = 1;
    
    // If this is an assertion, whether it should be true or false.
    // Otherwise, don't set this field.
    optional bool assertion_value = 2;

}
